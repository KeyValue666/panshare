[TOC]



# 客户端模块

## 部分功能及实现方式

### 网站首页前后端交互过程

>   网站中的帖子都有分类id，当用户打开首页时，vue通过获取路由中的分类id，将该id和分页参数、排序方式包装成一个QueryWrapper对象传递给后端。后端接口接受到该对象后先采用validate进行参数校验，如果参数校验通过，则service层调用查询帖子的mapper接口中的指定方法，该方法中存在拼接的动态SQL语句。具体SQL语句请查看`com.panshare.client.mapper.getPostByTagId`，service层将该查询获得的结果经过page-helper二次封装后放到同一返回结果R的data中，并返回给前端。

### 网站注册和登录功能设计

>   一、网站注册
>
>   注册功能需要用户填写邮箱、用户名、密码和邮箱验证码四部分信息。过程如下：
>
>   1.  用户在填写好邮箱后，前端先验证邮箱和其它信息格式的正确性，如果通过用户才能点击获取验证码按钮。
>   2.  后台接收到邮箱后再对邮箱进行一次格式校验和缓存校验。缓存校验是指redis中可能存在用户之前没有过期的验证码，如果缓存校验没有通过返回给用户提示信息。这样可以减少后续的数据库查重操作和保障短信接口的安全。
>   3.  校验成功后查询数据库中是否存在相同的邮箱(同一邮箱不能注册两次)。如果存在相同邮箱报错返回，反之执行下一步。
>   4.  邮箱状态正确后，调用邮箱发送接口，该接口会返回一个随机验证码。以用户传过来的Email为key，随机验证码为value存入到redis中并设置过期时间为5分钟。
>   5.  用户在获取到验证码后将和其它信息由前端封装成一个registry对象传递给后端。后端接收到后先对该对象进行格式校验，通过后执行下一步。
>   6.  格式校验通过后，首先查询redis中是否存在以用户提交的邮箱为key，验证码为键的键值对。不存在在则返回错误提示信息。反之执行下一步
>   7.  通过注入HttpServeletRequest获取注册用户的ip地址信息并和registry封装成一个对象存入数据库。
>   8.  根据用户id生成token返回给前端
>
>   二、登录
>
>   1.  前端首先对用户输入的用邮箱和密码进行格式校验，校验成功后，发送给后端。
>   2.  后端对接收到的参数再次进行格式校验，格式校验通过则查询数据库比对用户输入的信息。
>   3.  如果用户名和密码比对成功，则使用用户id(以后需要鉴权的接口通过解析token中的id，并将该id放到ThreadLocal中)生成token返回给前端。

### 点赞功能设计

>   说明：点赞功能属于高频操作，频繁的数据库操作会降低系统性能。我的设计思路如下：
>
>   1.  将用户的点赞记录存储在redis中，数据结构采用set类型。
>   2.  其中以点赞类型(帖子or评论)+点赞id(帖子id或者评论id)为键，用户id为值。因为set类型保证了数据的唯一性，所以，这也防止了用户刷赞的行为。
>   3.  当每次用户请求帖子和评论页面时，后端会将从数据库中查询到的数据经redis进行"过滤"。"过滤"目的一是统计该帖子或评论在redis中set的长度，也即是点赞的数量。目的二是鉴别登录用户是否曾经点过赞。
>
>   该设计存在的缺陷
>
>   1.  点赞的数据如何持久化问题
>
>       >设计之初的思路是使用Spring-quertze定时同步redis中的数据到数据库中，但是数据库设计不太规范，帖字点赞量和帖子的属性信息设计到同一张表中了:sob:。这也意味着如果redis中的数据同步到数据库中，数据库只记录了帖子点赞的数量，没有记录点赞的关系，意味着是谁点的赞就不能确认了，这将会导致用户存在刷赞问题。这个问题要想解决需要再增加一个点赞关联表，但是这样service层的业务逻辑需要重构。目前的设计除了不能持久化存储，但其它问题都能照顾到，前提是redis不存在宕机问题:joy:。

### 举报机制设计

>   1.  首先用户必须在已登录的情况下才能对帖子或者评论进行举报。
>   2.  前端将举报信息(举报类型(帖子or评论)、帖子or评论的id、举报附件等)封装成一个report对象传递给后端，后端先对该请求进行登录认证，也就是解析token，如果token解析通过，则将token解析除出的用户id放到ThreadLocal中，为了往后将举报信息和用户信息写到数据库中。
>   3.  当解析token无误后，则查询redis中是否已经存在该用户对该帖子的举报信息。该条信息在redis中以帖子类型+帖子id为键，以用户id为键，数据结构采用string，以3天为过期时间。当下次用户举报时会查询缓存，防止用户重复举报。

### 网站内容搜索功能设计

>   网站搜索功能使用了ElasticSearch，目前ElasticSearch中的数据都是自己手动将数据库中数据同步到其中的，往后可能会设置定时任务同步数据。
>
>   目前存在以下问题：
>
>   1.  数据不同步
>
>       >无论是自己手动同步数据还是往后可能使用定时任务同步数据，都是一次性将数据库中的数据同步到ES中。可是网站中存在以下操作,如：用户删除自己的帖子或者管理员删除帖子，那么此时ES中的数据将不再和mysql中的数据保持同步。如果每次管理员或者用户删除帖子时都更新一下ES又感觉耦合度太高了，而且每次更新ES操作还会导致接口响应效率变慢。网上一番查询可以异步同步ES，这样虽然能提高接口的响应效率，但是还是不能做到解耦合，不够优雅:joy:。目前还没有更好的思路:sob:。
>
>   2.  ES服务器宕机
>
>       >   因为服务器为2核2G，服务都开启后往往内存就满了，ES因此常常掉线……

### 帖子内容存储设计

>   帖子内容存储设计主要存在以下几个问题：
>
>   1.  在数据库中的存储格式
>
>       >   网站设计的初衷就是分享网盘链接，所以一张帖子的内容不会太长，数据库中便采用text字段进行存储，内容为html格式。
>
>   2.  前后端预防XSS
>
>       >   因为数据库中存储的是html格式，而且前端也是使用vue的v-html展示的，这意味很容易造成xss攻击。预防方式：
>       >
>       >   1.  前端使用的wangedit已经在提交文本时对html标记进行了转义
>       >   2.  后端使用html工具类进行了二次转义

### 网站接口设计

>   1.  接口的参数都是经过Hibbernate-Validate校验之后放行的，部分用户接口需要经过拦截器解析token。
>   2.  接口采用Spring-Aop监控各个service，当延迟超过一定时长时会被计入警告日志，方便后续分析。

### 邮箱接口防盗刷设计

>   这个设计采取了比较粗暴的方式，我在邮箱服务(已注入Spring)中注入了HttpServeletRequest对象，通过request对象获取请求IP，以该ip为键，布尔值为键值存入redis中，数据结构采用string，并设置超时时间为3分钟，每次调用邮箱接口时都会先走缓存，如果缓存没有过时则会抛异常。但是这样防止不了代理IP频繁访问的该接口……

### 帖子置顶设计

>   帖子在数据库中存在一个is_top字段，该字段类型为布尔类型，每次需要查询时将查询的结果按照该字段进行降序排列就能做到置顶操作了。

## TODO_LIST

1.  用户互相关注和订阅
2.  显示帖子浏览量
3.  用户签到
3.  发帖排行榜

